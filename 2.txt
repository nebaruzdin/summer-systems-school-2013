------------------------------------------------------------------------
1. Что такое factory, каким образом используется и для чего?

Это объект ядра, который позволяет создавать другие объекты ядра,
например, IPC gate. Он используется для контроля за созданием объектов
ядра. Мы можем, скажем, вести счётчик созданных объектов ядра или
запретить потоку создавать новые IPC gates и, таким образом, запретить
ему общение с другими объектами.


------------------------------------------------------------------------
2. Что такое target_cap, thread_cap? Область видимости gate.

target_cap — это свободная capability в capability list процесса, с
которой связывается создаваемый объект.

thread_cap — это capability, указывающая на поток, который будет
привязан к создаваемому IPC gate, то есть этот поток (и только этот)
будет получать сообщения через данный IPC gate. При этом любой другой
поток, который имеет соответствующую capability может посылать сообщения
с помощью данного IPC gate.


------------------------------------------------------------------------
3. Структура UTCB и назначение каждого из полей.

UTCB разбит на три области:

Регистры сообщения (message registers) — используются для хранения
информации, которую необходимо напрямую отправить ядру. Например, это
могут быть параметры системного вызова. В случае межроцессного общения
данная область копируется в UTCB принимающей стороны, откуда она может
впоследствии считать переданную информацию.

Буферные регистры (buffer registers) — используются для хранения
дескрипторов flexpage, которые представляют собой дескрипторы ресурсов и
позволяют предоставлять кому-то доступ к данным ресурсы.

Регистры управления потоком (thread control registers) — используются
для хранения локальных данных о потоке. Они остаются неизменными при
системных вызовых и также не копируются в случае межпроцессной
коммуникации.


------------------------------------------------------------------------
4. Что происходит, когда истекает timout в IPC?

Поток разблокируется и может провести некоторую обработку события:
например, сообщить об ошибке.


------------------------------------------------------------------------
5. Есть ли ограничения на длинну IPC message?

IPC message ограничено размером UTCB блока (областью регистров
сообщения).


------------------------------------------------------------------------
6. Что такое IDL compiler, зачем он нужен и какие проблемы решает?

Для передачи сообщений в рамках IPC в микроядрах L4 требуется совершать
множество однообразных действий, что порождает кодирование методом
copy-paste, ошибки по невнимательности и отвлекает программиста от сути.

Однако эти действия можно автоматизировать, используя так называемый
"язык описания интерфейса" (interface definition language, IDL). IDL
предоставляет высокоуровневое описание интерфейса (например, список
функций-служб, которые должен поддерживать сервер).

IDL compiler использует эти описания для автоматической генерации кода,
чем упрощает работу программиста.


------------------------------------------------------------------------
7. Как эти проблемы решены в GNU/Mach (вдруг вы знаете), как он решаются
   в L4Re?

В Mach, судя по всему, используется собственный IDL-компилятор MIG (Mach
interface generator), позволяющий реализовать интерфейс удалённого
вызова процедур (RPC), используя для этого функции-обёртки, которые
осуществляют передачу аргументов в виде сообщений для которых
выполняется маршалинг/демаршалинг.

В ранних версиях L4 также использовался IDL compiler, называемый DICE.
Однако из-за того, что он стал слишком большим и сложным, от него в
настоящее время временно отказались.

В L4Re (и Genode) кроме того существует интеграция IPC c C++ в виде
библиотеки потоков (stream library), что позволяет использовать обычные
операторы С++ для работы с потоками при программировании межпроцессного
взаимодействия.


------------------------------------------------------------------------
8. Communication channel и IPC gate - одно и то же?

Communication channel — это абстракция, реализацией которой в Fiasco.OC
является объект IPC gate.


------------------------------------------------------------------------
9. Так всё же, каким образом сервер узнаёт какую dispatch функцию
   вызывать?

10. А если у нас несколько каналов?

Есть два варинта реализации обработки сообщений сервером:

Если у нас имеется только один канал (IPC gate), связанный с сервером,
необходимо создать класс, наследующий L4::Server, и реализовать в нём
функцию dispatch(), вызываемую в основном цикле сервера.

Если имеется несколько каналов и, соответственно, несколько связанных с
ними серверных объектов (L4::Server_object), необходимо прямо или через
другие классы унаследоваться от класса L4::Basic_registry. Этот класс
реализует регистр, в котором хранятся все объекты сервера, а также
функцию find(id), возвращающую объект сервера, ответственный за
обработку сообщений с данным id. Этот id является меткой IPC
gate, через который пришло сообщение.


------------------------------------------------------------------------
11. Опишите, пожалуйста, механизм работы sigma0, каким образом
    обрабатываются page fault?


------------------------------------------------------------------------
12. У каждого треда есть pager - обработчик page fault.


------------------------------------------------------------------------
13. Что такое flexpage и зачем это нужно?


------------------------------------------------------------------------
14. Опишите, пожалуйста, проблему иерархических мапингов и метод её
    решения в Fiasco.OC


------------------------------------------------------------------------
15. Что такое dataspace, каким образом с этой абстракцией осуществляется
    работа?


------------------------------------------------------------------------
16. Как, используя dataspace, передавать данные между серверами?
