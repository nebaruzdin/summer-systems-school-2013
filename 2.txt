------------------------------------------------------------------------
1. Что такое factory, каким образом используется и для чего?

Это объект ядра, который позволяет создавать другие объекты ядра,
например, IPC gate. Он используется для контроля за созданием объектов
ядра. Мы можем, скажем, вести счётчик созданных объектов ядра или
запретить потоку создавать новые IPC gates и, таким образом, запретить
ему общение с другими объектами.


------------------------------------------------------------------------
2. Что такое target_cap, thread_cap? Область видимости gate.

target_cap — это свободная capability в capability list процесса, с
которой связывается создаваемый объект.

thread_cap — это capability, указывающая на поток, который будет
привязан к создаваемому IPC gate, то есть этот поток (и только этот)
будет получать сообщения через данный IPC gate. При этом любой другой
поток, который имеет соответствующую capability может посылать сообщения
с помощью данного IPC gate.


------------------------------------------------------------------------
3. Структура UTCB и назначение каждого из полей.

UTCB разбит на три области:

Регистры сообщения (message registers) — используются для хранения
информации, которую необходимо напрямую отправить ядру. Например, это
могут быть параметры системного вызова. В случае межроцессного общения
данная область копируется в UTCB принимающей стороны, откуда она может
впоследствии считать переданную информацию.

Буферные регистры (buffer registers) — используются для хранения
дескрипторов flexpage, которые представляют собой дескрипторы ресурсов и
позволяют предоставлять кому-то доступ к данным ресурсы.

Регистры управления потоком (thread control registers) — используются
для хранения локальных данных о потоке. Они остаются неизменными при
системных вызовых и также не копируются в случае межпроцессной
коммуникации.


------------------------------------------------------------------------
4. Что происходит, когда истекает timout в IPC?

Поток разблокируется и может провести некоторую обработку события:
например, сообщить об ошибке.


------------------------------------------------------------------------
5. Есть ли ограничения на длинну IPC message?

IPC message ограничено размером UTCB блока (областью регистров
сообщения).


------------------------------------------------------------------------
6. Что такое IDL compiler, зачем он нужен и какие проблемы решает?

Для передачи сообщений в рамках IPC в микроядрах L4 требуется совершать
множество однообразных действий, что порождает кодирование методом
copy-paste, ошибки по невнимательности и отвлекает программиста от сути.

Однако эти действия можно автоматизировать, используя так называемый
"язык описания интерфейса" (interface definition language, IDL). IDL
предоставляет высокоуровневое описание интерфейса (например, список
функций-служб, которые должен поддерживать сервер).

IDL compiler использует эти описания для автоматической генерации кода,
чем упрощает работу программиста.


------------------------------------------------------------------------
7. Как эти проблемы решены в GNU/Mach (вдруг вы знаете), как он решаются
   в L4Re?

В Mach, судя по всему, используется собственный IDL-компилятор MIG (Mach
interface generator), позволяющий реализовать интерфейс удалённого
вызова процедур (RPC), используя для этого функции-обёртки, которые
осуществляют передачу аргументов в виде сообщений для которых
выполняется маршалинг/демаршалинг.

В ранних версиях L4 также использовался IDL compiler, называемый DICE.
Однако из-за того, что он стал слишком большим и сложным, от него в
настоящее время временно отказались.

В L4Re (и Genode) кроме того существует интеграция IPC c C++ в виде
библиотеки потоков (stream library), что позволяет использовать обычные
операторы С++ для работы с потоками при программировании межпроцессного
взаимодействия.


------------------------------------------------------------------------
8. Communication channel и IPC gate - одно и то же?

Communication channel — это абстракция, реализацией которой в Fiasco.OC
является объект IPC gate.


------------------------------------------------------------------------
9. Так всё же, каким образом сервер узнаёт какую dispatch функцию
   вызывать?

10. А если у нас несколько каналов?

Есть два варинта реализации обработки сообщений сервером:

Если у нас имеется только один канал (IPC gate), связанный с сервером,
необходимо создать класс, наследующий L4::Server, и реализовать в нём
функцию dispatch(), вызываемую в основном цикле сервера.

Если имеется несколько каналов и, соответственно, несколько связанных с
ними серверных объектов (L4::Server_object), необходимо прямо или через
другие классы унаследоваться от класса L4::Basic_registry. Этот класс
реализует регистр, в котором хранятся все объекты сервера, а также
функцию find(id), возвращающую объект сервера, ответственный за
обработку сообщений с данным id. Этот id является меткой IPC
gate, через который пришло сообщение.


------------------------------------------------------------------------
11. Опишите, пожалуйста, механизм работы sigma0, каким образом
    обрабатываются page fault?

Sigma0 — это менеджер ресурсов в ОС семейства L4. Он запускается ядром
как первый процесс и получает доступ ко всем физическим ресурсам
вычислительной системы.

При старте системы помимо Sigma0 запускается также Moe, который является
менеджером ресурсов в L4Re. Он в свою очередь либо непосредственно
запускает определённое приложение, либо использует инициализационный
скрипт для запуска приложений.

Только что запущенный поток обладает пустым адресным пространством.
Поэтому, когда он начинает выполняться, попытка обратиться по адресу в
EIP приводит к внутреннему прерывания page fault.

Управление передаётся в ядро, в page fault handler, который генерирует
IPC-сообщение для специального потока, называемого pager. Pager выбирает
для отображения в виртуальную память первоначального процесса область
выделенной ему памяти и посылает ответ в ядро. Ядро соответствующим
образом меняет таблицы страниц целевого адресного пространства и после
этого возобновляет работу изначального потока.


------------------------------------------------------------------------
12. У каждого треда есть pager - обработчик page fault?

У каждого, за исключением изначального pager — Sigma0.


------------------------------------------------------------------------
13. Что такое flexpage и зачем это нужно?

flexpage — это специальная структура данных в Fiasco.OC, описывающая
участок памяти. Она состоит из начального адреса, размера участка и
определённых прав.

Pager помещает дескрипторы flexpage в буферные регистры UTCB, отвечая на
сообщение ядра. Основываясь на этой информации, ядро изменяет таблицы
страниц так, чтобы обеспечить отображение памяти, выбранное pager и
описанное с помощью flexpage.


------------------------------------------------------------------------
14. Опишите, пожалуйста, проблему иерархических мапингов и метод её
    решения в Fiasco.OC

Ветки "дерева" отображаемой pager'ами памяти могут сливаться, и таким
образом в памяти приложения оказываются несколько участков памяти,
выделенных разными pager. Соответственно, мы должны каким-то образом
определять, какой из pager'ов ответственен за обработку возникшего page
fault.

Проблема решается при помощи специального потока внутри приложения,
называемого region mapper и являющегося pager'ом всех остальных потоков.
RM управляет таблицей, которая содержит сведения о том, какой участок
памяти каким pager'ом должен обрабатываться.

Когда возникает page fault, ядро уведомляет об этом RM, который затем
определяет, какой поток является непосредственным pager участка памяти,
в котором возник page fault, и перенаправляет запрос этому потоку.


------------------------------------------------------------------------
15. Что такое dataspace, каким образом с этой абстракцией осуществляется
    работа?

Dataspace — это абстракция, используемая в L4Re, описывающая некоторый
обобщённый объект памяти, независимый от конкретного источника этой
памяти.

Пользовательское приложение получает capability некоторого dataspace и
запрашивает свой RM прикрепить данный dataspace к своей виртуальной
памяти. RM находит место в виртуальной памяти процесса для размещения
dataspace и заносит соответствующую запись в таблицу участков памяти.
Таким образом, когда в этом участке памяти возникает page fault, RM
знает, какой dataspace manager должен его обрабатывать.


------------------------------------------------------------------------
16. Как, используя dataspace, передавать данные между серверами?

Можно выделить в памяти dataspace и прикрепить его к виртуальным
адресным пространствам различных процессов и, в результате, иметь
разделяемую память произвольного размера.
